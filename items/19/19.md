# 추론 가능한 타입을 사용해 장황한 코드 방지하기

- 타입추론을 적극적으로 사용해서 불필요한 타입 구문을 넣지 말아라.

  - 코드의 모든 변수에 타입을 선언하는 것은 비생산적이며, 형편없는 스타일로 여겨진다.

- 비구조화 할당문은 모든 지역 변수의 타입이 추론되도록 한다. 그래서 여기에 추가적으로 불필요하게 타입을 넣으면 코드가 번잡해진다.

- 매개변수의 타입은 명시해야한다. 어떤 언어들은 매개변수의 최종 사용처까지 참고하여 타입을 추론하지만, 타입스크립트는 그렇게까지는 하지 않으며 일반적으로 처음 등장할 때 타입이 결정된다. **다만, 매개변수에 기본값이 있으면 타입 구문을 생략할 수도 있다.**

- 이상적인 타입스크립트 코드는 **함수 시그니처**에 타입 구문을 포함하지만, **함수 내에서 생성된 지역변수에는 타입 구문을 넣지 않는다.**

### 타입추론이 되지만, 그래도 타입을 명시하고 싶은 상황이 몇가지가 있긴한다.

**1. 객체 리터럴을 정의할 때**

- 객체 리터럴을 정의할 때 타입을 명시하면, `잉여 속성 체크`가 동작한다. 그리고 변수가 사용되는 순간이 아닌 할당하는 시점에 오류가 표시되도록 해준다. 타입을 명시하지 않은 경우에는 변수를 사용하는 순간 (함수의 인자에 넣었을 때, 거기에서 에러)에 에러가 표시된다.

```ts
// 객체 리터럴을 정의할 때 타입 명시를 하지 않은 경우.
type Obj = {
  name: string;
};

const func = (obj: Obj) => {
  return obj;
};

const obj = {
  name: "with",
  age: 10, // ok (구조적 타이핑에 의해 obj는 Obj의 서브타입이므로 타입체커 상에서 문제없음)
};

func(obj); // ok
```

```ts
// 객체 리터럴을 정의할 때 타입 명시 했을 때
type Obj = {
  name: string;
};

const func = (obj: Obj) => {
  return obj;
};

const obj: Obj = {
  name: "with",
  age: 10, // error (개체 리터럴은 알려진 속성만 지정할 수 있으며 'Obj' 형식에 'age'이(가) 없습니다. -> 잉여 속성 체크 동작),
  // 변수를 할당하는 시점부터 이미 error 발생
};

func(obj); // ok
```

**2. 함수의 반환값에**

- 함수의 반환도 타입이 추론되지만, 먼저 타입을 명시하면 예기치못한 오류를 방지할 수 있다.
- 함수에 대해서 더 명확하게 알 수 있다. 함수를 구현하기전 먼저 함수 시그니처를 작성함으로서 주먹구구식의 함수 시그니처 작성을 방지하고, 마치 TDD처럼 코드를 작성할 수 있다.
- 호환이 되는 타입이지만, 표시가 되는 타입이 사용자가 의도한 값이 아닐 수 있어 명시해주는 것이 좋다. 예를 들어 `type T = { x: string; y: string; }` 이고 어떤 함수의 반환값의 타입이 T일때, 명시하지 않으면 `T`로 보이지 않고, `{ x: string; y: string; }`로 보일 것 이다. (이름이 있는 타입을 `명명된 타입`이라고 한다.)
